# go를 활용한 채팅서버 구현
- go의 고루틴, 채널 활용 동시접속자에게 순차적 닉네임 부여
- 실시간 채팅 입장/퇴장 처리

# 요약
1. 접속 순서대로 1, 2, 3, 자동부여
2. WebSocket 기반 실시간 통신
3. 유저 입장/퇴장/채팅 브로드캐스트
4. 고루틴, 채널, 뮤택스 기반의 동시성처리
5. 데드락, 고루틴 누수 등 문제 해결 포함

# 사용 기술
1. Goroutine
- go 에서 제공하는 경량 스레드, 하나의 OS스레드 위에서 여러 작업을 동시에 실행
- 가벼운 장점이 있음
    - OS스레드는 생성시 최소 1mb이상의 스택 메모리 확보
    - 고루틴은 2kb 스택으로 시작, 필요하면 확장
    - OS스레드는 커널이 관리 -> 생성비용 큼
    - 고루틴은 go런타임이 관리 -> 사용자 공간에서 처리 -> 컨텍스트 스위칭 비용이 낮음
    - Go는 M:N 구조 사용
        - 여러개의 고루틴을
        - 적은수의 OS스레드 위에서
        - Go 런타임 스케쥴러가 효율적 실행
- 한마디로 작은 스택, 런타임 스케쥴링, 낮은 컨텍스트 스위칭 비용 때문에 대규모 처리가 가능

2. Channel
- 고루틴 간 안전한 메세지 전달
- 고루틴은 동시에 실행 , 여러개의 고루틴이 하나의 데이터를 동시 수정하면 데이터 충돌
- 채널을 사용하여 데이터 접근 직렬화, Go런타임이 동기화 보장

3. 비동기처리
- 작업이 끝날때까지 기다리지 않고 다른 작업 수행
- 각 클라이언트별로 read/write를 별도 고루틴으로 처리

4. WebSocket
- 서버 - 클라이언트 간 양방향 통신 가능
- 지속 연결 + 실시간성

5. Mutex
- 여러 개의 고루틴의 접근 방지
- 닉네임 발급에 사용

6. 이벤트 루프 기반 허브
- 하나의 고루틴이 여러 이벤트 채널 관리
- 모든 상태 변경을 하나의 고루틴이 관리 -> 동시성버그 줄임

7. 고루틴 누수 방지 설계
- 유저 종료시 close
- 허브 종료시 모든 채널 정리

## 트러블슈팅
- 데드락 발생
```go
// hub.Run()에서 발생
h.broadcast <- b
```
- 자기 자신에게 메세지 보내고 받는 구조
    - Hub.Run() -> 이벤트 고루틴
    - 이 고루틴이 select로 broadcast를 읽음
    - 그런데 그 안에서 다시 broadcast로 send
    - 자기 스스로를 block
    - 서버에 문제를 일으키지 않지만, 내부 로직을 정지시킴
```go
// 해결방법
func (h *Hub) broadcastToAll(message []byte) {
    for c:= range h.clients {
        select {
        case c.send <- message:
        default:
            close(c.send)
            _ = c.Conn.Close()
            delete(h.clients, c)    
        }
    }
}

// Run내부
h.broadcastToAll(b)
```
- 배운점
    1. 이벤트 루프 안에서 같은 채널로 send 금지
    2. 동시성 문제는 논리보다 흐름 관점에서 봐야한다
    3. 누가 send, 누가 recive하는지 명확히하기